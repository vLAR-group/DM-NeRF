import os
import json
import torch
import numpy as np

from networks.helpers import r_x, r_y, r_z



trans_t = lambda t: torch.Tensor([
    [1, 0, 0, 0],
    [0, 1, 0, 0],
    [0, 0, 1, t],
    [0, 0, 0, 1]]).float()

rot_phi = lambda phi: torch.Tensor([
    [1, 0, 0, 0],
    [0, np.cos(phi), -np.sin(phi), 0],
    [0, np.sin(phi), np.cos(phi), 0],
    [0, 0, 0, 1]]).float()

rot_theta = lambda th: torch.Tensor([
    [np.cos(th), 0, -np.sin(th), 0],
    [0, 1, 0, 0],
    [np.sin(th), 0, np.cos(th), 0],
    [0, 0, 0, 1]]).float()


def pose_spherical(theta, phi, radius):
    c2w = trans_t(radius)
    c2w = rot_phi(phi / 180. * np.pi) @ c2w
    c2w = rot_theta(theta / 180. * np.pi) @ c2w
    c2w = torch.Tensor(np.array([[-1, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1]])) @ c2w
    return c2w


def load_mani_poses(args):
    load_path = os.path.join(args.datadir, 'mani', args.mani_mode, 'transformation_matrix.json')
    with open(load_path, 'r') as rf:
        obj_trans = json.load(rf)
    rf.close()
    return obj_trans


def load_mani_demo_poses(args):
    load_path = os.path.join(args.datadir, 'mani', 'transformation_matrix.json')
    with open(load_path, 'r') as rf:
        obj_trans = json.load(rf)
    rf.close()
    return obj_trans


def generate_poses_eval(args, defined_transformations=None):
    mani_centers = {'bathroom': [0.779178, 1.05247, 0.380208], 'bedroom': [-1.29552, 1.72703, 0.2946],
                    'dinning': [-0.633653, 0.295162, 0.279743], 'kitchen': [-2.52579, -0.103821, 1.47165],
                    'reception': [0.579352, -0.099242, 0.092597], 'restroom': [-0.001277, -2.85079, 0.588084],
                    'office': [-0.717374, 0.929292, 0.904515], 'study': [-0.519422, -2.16509, 1.07392]}
    """pose also can generated by yourself or selected from the data set"""
    # import you self designed transformation matrix
    transformations = {}
    save_path = os.path.join(args.datadir, 'mani', args.mani_mode, 'transformation_matrix.json')
    poses_list = []
    if defined_transformations is not None:
        """this branch for the new target poses you support"""
        pass
    else:
        mani_center = np.array(mani_centers[args.expname])
        translation = np.eye(4, 4, dtype=np.float32)
        translation[:3, -1] = -1 * mani_center
        translation_inverse = np.eye(4, 4, dtype=np.float32)
        translation_inverse[:3, -1] = -1 * translation[:3, -1]
        if args.mani_mode == 'translation':
            t = np.array([[1, 0, 0, 0],
                          [0, 1, 0, -0.25],
                          [0, 0, 1, 0],
                          [0, 0, 0, 1]])
            tar_pose = translation_inverse @ t @ translation
            pose_dict = dict({'transformation': tar_pose.tolist(), 'mode': 'translation'})
            poses_list.append(pose_dict)
        if args.mani_mode == 'rotation':
            'self rotation'
            roll = np.zeros(1)
            pitch = np.zeros(1)
            yaw = np.array([90 * np.pi / 180])
            r = r_z(yaw[0]) @ r_y(pitch[0]) @ r_x(roll[0])
            tar_pose = translation_inverse @ r @ translation
            pose_dict = dict({'transformation': tar_pose.tolist(), 'mode': 'rotation'})
            poses_list.append(pose_dict)
        if args.mani_mode == 'scale':
            scales = np.array([1.2])
            for i in range(len(scales)):
                s = np.array([[scales[i], 0, 0, 0],
                              [0, scales[i], 0, 0],
                              [0, 0, scales[i], 0],
                              [0, 0, 0, 1]])
                tar_pose = translation_inverse @ s @ translation
                pose_dict = dict({'transformation': tar_pose.tolist(), 'mode': 'scale'})
                poses_list.append(pose_dict)
        if args.mani_mode == 'multi':
            scales = np.array([1.2])

            s = np.array([[scales[0], 0, 0, 0],
                          [0, scales[0], 0, 0],
                          [0, 0, scales[0], 0],
                          [0, 0, 0, 1]])

            roll = np.zeros(1)
            pitch = np.zeros(1)
            yaw = np.array([90 * np.pi / 180])
            r = r_z(yaw[0]) @ r_y(pitch[0]) @ r_x(roll[0])
            multi_transforamtion = s @ r

            distance = - 0.25
            t = np.array([[1, 0, 0, 0],
                          [0, 1, 0, distance],
                          [0, 0, 1, 0],
                          [0, 0, 0, 1]])

            multi_transforamtion = multi_transforamtion @ t
            tar_pose = translation_inverse @ multi_transforamtion @ translation
            pose_dict = dict({'transformation': tar_pose.tolist(), 'mode': 'multi'})
            poses_list.append(pose_dict)
    transformations.update({'transformations': poses_list})
    with open(save_path, 'w') as fp:
        json.dump(transformations, fp, ensure_ascii=False, indent=2)
    fp.close()

    return transformations


def generate_poses_demo(objs, args, defined_transformations=None):
    """pose also can generated by yourself or selected from the data set"""
    # import you self designed transformation matrix
    save_path = os.path.join(args.datadir, 'mani', 'transformation_matrix.json')
    out_puts = {}
    views = args.views
    for obj in objs:
        obj_name = obj["obj_name"]
        mani_center = obj["obj_center"]
        mani_mode = obj["mani_mode"]

        obj_transformations = {}
        poses_list = []
        mani_center = np.array(mani_center)
        translation = np.eye(4, 4, dtype=np.float32)
        translation[:3, -1] = -1 * mani_center
        translation_inverse = np.eye(4, 4, dtype=np.float32)
        translation_inverse[:3, -1] = -1 * translation[:3, -1]
        if mani_mode == 'translation':
            oper_dists = obj['distance']
            num = len(oper_dists)
            for oper_dist in oper_dists:
                move_step = 2 * num
                oper_dist_step = np.array([[1, 0, 0, oper_dist / views],
                                           [0, 1, 0, 0],
                                           [0, 0, 1, 0],
                                           [0, 0, 0, 1]])
                t = np.array([[1, 0, 0, 0],
                              [0, 1, 0, 0],
                              [0, 0, 1, 0],
                              [0, 0, 0, 1]])
                # for i in range(0, views // move_step):
                for i in range(0, views):
                    if i == 0:
                        t = t
                    else:
                        t = t @ oper_dist_step
                    tar_pose = translation_inverse @ t @ translation
                    pose_dict = dict({'transformation': tar_pose.tolist(), 'mode': 'translation'})
                    poses_list.append(pose_dict)

        if mani_mode == 'rotation':
            oper_degree = obj["rotation"]
            'self rotation'
            roll = np.zeros(1)
            pitch = np.zeros(1)
            move_step = 2
            rotation_step = oper_degree / (views // move_step)

            # degree = np.concatenate((np.linspace(270, 360, 90), np.linspace(0, 180, 180)))
            degree = np.linspace(0, 180, views)
            # rotation_step = oper_degree / views
            for i in range(0, len(degree)):
                # degree = degree + rotation_step * i
                yaw = np.array([degree[i] * np.pi / 180])
                r = r_z(yaw[0]) @ r_y(pitch[0]) @ r_x(roll[0])
                tar_pose = translation_inverse @ r @ translation
                pose_dict = dict({'transformation': tar_pose.tolist(), 'mode': 'rotation'})
                poses_list.append(pose_dict)

        if mani_mode == 'scale':
            scales = np.array([1.2])
            for i in range(len(scales)):
                s = np.array([[scales[i], 0, 0, 0],
                              [0, scales[i], 0, 0],
                              [0, 0, scales[i], 0],
                              [0, 0, 0, 1]])
                tar_pose = translation_inverse @ s @ translation
                pose_dict = dict({'transformation': tar_pose.tolist(), 'mode': 'scale'})
                poses_list.append(pose_dict)
        if mani_mode == 'multi':
            scales = np.array([1.2])
            s = np.array([[scales[0], 0, 0, 0],
                          [0, scales[0], 0, 0],
                          [0, 0, scales[0], 0],
                          [0, 0, 0, 1]])

            roll = np.zeros(1)
            pitch = np.zeros(1)
            yaw = np.array([90 * np.pi / 180])
            r = r_z(yaw[0]) @ r_y(pitch[0]) @ r_x(roll[0])
            multi_transforamtion = s @ r

            distance = - 0.25
            t = np.array([[1, 0, 0, 0],
                          [0, 1, 0, distance],
                          [0, 0, 1, 0],
                          [0, 0, 0, 1]])

            multi_transforamtion = multi_transforamtion @ t
            tar_pose = translation_inverse @ multi_transforamtion @ translation
            pose_dict = dict({'transformation': tar_pose.tolist(), 'mode': 'multi'})
            poses_list.append(pose_dict)
        if mani_mode == 'deform':
            continue
        obj_transformations.update({obj_name: poses_list})
        out_puts.update(obj_transformations)
    with open(save_path, 'w') as fp:
        json.dump(out_puts, fp, ensure_ascii=False, indent=2)
    fp.close()

    return
